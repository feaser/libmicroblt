{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to LibMicroBLT The LibMicroBLT library encompasses all the functionality needed to perform a firmware update on another microcontroller, running the OpenBLT bootloader . In essence, LibMicroBLT is a microcontroller optimized version of LibOpenBLT . The latter one was designed for PCs and embedded Linux devices. LibMicroBLT assumes that the main controller features a file system for the storing firmware files. For example on an SD card, USB stick or a flash memory chip. Internally, the library uses the FatFs software component for accessing the file system: You are free to choose how the firmware files end up on the file system. A few ideas: Manually copied from your PC. Downloaded from an FTP server or network drive. Downloaded from cloud storage (S3 bucket, Dropbox, Google Drive, OneDrive, etc.) LibMicroBLT is written in the C programming language (C99) with MISRA compliance in mind. Thanks to its permissive MIT license , you are free to integrate and distribute the library in your commercial closed source firmware. The library is hardware independent. With the help of the port module, you can link your own implemented hardware specifics. The included demo application provides an example of how to implement these port specific functions. This user manual includes an API reference , explaining in details how to use LibMicroBLT. The getting started section of this user manual contains instructions on how to get LibMicroBLT integrated and up-and-running on your microcontroller. Example system Combining LibMicroBLT with OpenBLT's Master/Slave Gateway add-on module opens the path to all sorts of nifty system architectures for performing firmware updates. For example: The main controller, running LibMicroBLT, could perform firmware updates on all attached nodes. In this system architecture, you would just need to integrate the Master/Slave Gateway add-on module with the OpenBLT bootloaders on Node A1 and Node B1 . Library architecture The following image illustrates the modular architecture of LibMicroBLT and how it fits into your firmware: Firmware typically consist of: HAL - Hardware Abstraction Layer. For accessing low-level microcontroller peripherals. OS - Operating System. Either the good ol' super loop or a real-time operating system (RTOS). APP - Your actual application. The LibMicroBLT library sits in between your application and the hardware abstraction layer. That way your own application can call its functions for performing a firmware update on another microcontroller, which runs the OpenBLT bootloader. Furthermore, the library requires access to some hardware specifics. For example to access a timer and communication peripheral(s). LibMicroBLT itself depends on two third-party libraries: FatFS for file system access to read the actual firmware files. MicroTBX for assertions, critical sections, heap, memory pools and linked lists. Inside LibMicroBLT, you'll find three modules: Firmware module - The firmware module embeds all the functionality for reading firmware data from a firmware file. Session module - The session module implements all the functionality for communicating with the OpenBLT bootloader running the other microcontroller(s). Port module - The port module makes it possible to connect your hardware specifics to the hardware independent LibMicroBLT library.","title":"Home"},{"location":"#introduction-to-libmicroblt","text":"The LibMicroBLT library encompasses all the functionality needed to perform a firmware update on another microcontroller, running the OpenBLT bootloader . In essence, LibMicroBLT is a microcontroller optimized version of LibOpenBLT . The latter one was designed for PCs and embedded Linux devices. LibMicroBLT assumes that the main controller features a file system for the storing firmware files. For example on an SD card, USB stick or a flash memory chip. Internally, the library uses the FatFs software component for accessing the file system: You are free to choose how the firmware files end up on the file system. A few ideas: Manually copied from your PC. Downloaded from an FTP server or network drive. Downloaded from cloud storage (S3 bucket, Dropbox, Google Drive, OneDrive, etc.) LibMicroBLT is written in the C programming language (C99) with MISRA compliance in mind. Thanks to its permissive MIT license , you are free to integrate and distribute the library in your commercial closed source firmware. The library is hardware independent. With the help of the port module, you can link your own implemented hardware specifics. The included demo application provides an example of how to implement these port specific functions. This user manual includes an API reference , explaining in details how to use LibMicroBLT. The getting started section of this user manual contains instructions on how to get LibMicroBLT integrated and up-and-running on your microcontroller.","title":"Introduction to LibMicroBLT"},{"location":"#example-system","text":"Combining LibMicroBLT with OpenBLT's Master/Slave Gateway add-on module opens the path to all sorts of nifty system architectures for performing firmware updates. For example: The main controller, running LibMicroBLT, could perform firmware updates on all attached nodes. In this system architecture, you would just need to integrate the Master/Slave Gateway add-on module with the OpenBLT bootloaders on Node A1 and Node B1 .","title":"Example system"},{"location":"#library-architecture","text":"The following image illustrates the modular architecture of LibMicroBLT and how it fits into your firmware: Firmware typically consist of: HAL - Hardware Abstraction Layer. For accessing low-level microcontroller peripherals. OS - Operating System. Either the good ol' super loop or a real-time operating system (RTOS). APP - Your actual application. The LibMicroBLT library sits in between your application and the hardware abstraction layer. That way your own application can call its functions for performing a firmware update on another microcontroller, which runs the OpenBLT bootloader. Furthermore, the library requires access to some hardware specifics. For example to access a timer and communication peripheral(s). LibMicroBLT itself depends on two third-party libraries: FatFS for file system access to read the actual firmware files. MicroTBX for assertions, critical sections, heap, memory pools and linked lists. Inside LibMicroBLT, you'll find three modules: Firmware module - The firmware module embeds all the functionality for reading firmware data from a firmware file. Session module - The session module implements all the functionality for communicating with the OpenBLT bootloader running the other microcontroller(s). Port module - The port module makes it possible to connect your hardware specifics to the hardware independent LibMicroBLT library.","title":"Library architecture"},{"location":"apiref/","text":"API reference This section provides a full reference of all the functions, macros and types that LibMicroBLT offers. Macros Macro Description BLT_VERSION_MAIN Main version number of LibMicroBLT. BLT_VERSION_MINOR Minor version number of LibMicroBLT. BLT_VERSION_PATCH Patch number of LibMicroBLT. BLT_SESSION_XCP_V10 Session type identifier for XCP version 1.0. BLT_FIRMWARE_READER_SRECORD Firmware type identifier for S-record firmware files. Types tBltSessionSettingsXcpV10 typedef struct tBltSessionSettingsXcpV10 Structure layout of the XCP version 1.0 session settings. Element Description timeoutT1 Command response timeout in milliseconds. timeoutT3 Start programming timeout in milliseconds. timeoutT4 Erase memory timeout in milliseconds. timeoutT5 Program memory and reset timeout in milliseconds. timeoutT6 Connect response timeout in milliseconds. timeoutT7 Busy wait timer timeout in milliseonds. connectMode Connection mode parameter in XCP connect command. tPortXcpPacket typedef struct tPortXcpPacket XCP packet type. Element Description data Byte array with packet data. len Number of data bytes stored in the packet. tPort typedef struct tPort Port interface. The port interface links the hardware specific implementation to the hardware independent library. Element Description SystemGetTime Function pointer to obtain the current system time in milliseconds. XcpTransmitPacket Function pointer to transmit an XCP packet using the transport layer implemented by the port. The transmission itself can be blocking. The function should return TBX_OK if the packet could be transmitted, TBX_ERROR otherwise. XcpReceivePacket Function pointer to receive an XCP packet using the transport layer implemented by the port. The reception should be non-blocking. The function should return TBX_TRUE if a packet was received, TBX_FALSE otherwise. A newly received packet should be stored in the rxPacket parameter. XcpComputeKeyFromSeed Function pointer to calculates the key to unlock the programming resource, based on the given seed. This function should return TBX_OK if the key could be calculated, TBX_ERROR otherwise. Note that it's okay to set this element to NULL , if you do not use the seed/key security feature of the OpenBLT bootloader. Functions Port module The port module makes it possible to connect your hardware specifics to the hardware independent LibMicroBLT library. In your own application you implement the port specific functions. For example for transmitting and receiving XCP communication packet on the transport layer of your choice. You then specify your port specific functions in a variable of type tPort . You pass this variable on as a parameter when calling function BltPortInit() , which links your hardware specifics to LibMicroBLT. For this reason, you should first call function BltPortInit() , before calling any other functions of LibMicroBLT. BltPortInit void BltPortInit(tPort const * port) Initializes the port module by linking the port specified by the parameter. Typically called once during firmware initialization. Must be called before calling any other functions of LibMicroBLT. Parameter Description port Pointer to the port to link (type tPort ). Example This example is taken from the LibMicroBLT demo application, where the application implements the hardware specific functions in: AppPortSystemGetTime() AppPortXcpTransmitPacket() AppPortXcpReceivePacket() AppPortXcpComputeKeyFromSeed() Refer to the LibMicroBLT demo application for an example on how to implement or port these functions for your own hardware. Once these port functions are implemented, you link them to LibMicroBLT like this: tPort const portInterface = { .SystemGetTime = AppPortSystemGetTime, .XcpTransmitPacket = AppPortXcpTransmitPacket, .XcpReceivePacket = AppPortXcpReceivePacket, .XcpComputeKeyFromSeed = AppPortXcpComputeKeyFromSeed }; BltPortInit(&portInterface); BltPortTerminate void BltPortTerminate(void) Terminates the port module. Typically called once during firmware exit. Embedded firmware tends to be driven by an infinite program loop and never exits. In such cases, you can omit calling this function. Session module The session module implements all the functionality for communicating with the OpenBLT bootloader running the other microcontroller(s); The ones on which you want to perform a firmware update from the microcontroller that runs this LibMicroBLT library. The functionality of the session module encompasses: Connect and disconnect. Erase, write and read memory. BltSessionInit void BltSessionInit(uint32_t type, void const * settings) Initializes the firmware update session for a specific communication protocol. This function is typically called at the start of the firmware update. Parameter Description type The communication protocol to use for this session. It should be a BLT_SESSION_xxx value. settings Pointer to a structure with communication protocol specific settings. Example Initialize the session module for communication using the XCP version 1.0 protocol: tBltSessionSettingsXcpV10 const sessionSettings = { .timeoutT1 = 1000U, .timeoutT3 = 2000U, .timeoutT4 = 10000U, .timeoutT5 = 1000U, .timeoutT6 = 50U, .timeoutT7 = 2000U, .connectMode = 0 }; BltSessionInit(BLT_SESSION_XCP_V10, &sessionSettings); BltSessionTerminate void BltSessionTerminate(void) Terminates the firmware update session. This function is typically called at the end of the firmware update. BltSessionStart uint8_t BltSessionStart(void) Starts the firmware update session. This is were the library attempts to activate and connect with the bootloader running on the target, through the transport layer that was specified during the session's initialization. Return value TBX_OK if successful, TBX_ERROR otherwise. Example When attempting to connect to the OpenBLT bootloader on the target microcontroller, the bootloader itself is often not yet active. Instead, the user's firmware is happily running. The firmware typically includes functionality to receive the connection request, after which it activates the bootloader by performing a software reset. If this functionality is not present, the user needs to manually reset the microcontroller. It's therefore recommended to try connecting to the OpenBLT bootloader, by calling BltSessionStart() repeatedly for a finite amount of time. Note that the following example also demonstrates how your own application can access the port specific functions: uint32_t const connectTimeout = 5000U; uint32_t connectStartTime; uint32_t connectDeltaTime; uint8_t connected = TBX_FALSE; /* Store start time. */ connectStartTime = PortGet()->SystemGetTime(); /* Attempt to connect to the target. */ connected = BltSessionStart(); /* Repeat connection attempt for a finite amount of time. */ while (connected == TBX_FALSE) { /* Attempt to connect to the target. */ connected = BltSessionStart(); /* Handle timeout detection if not yet connected. */ if (connected == TBX_FALSE) { /* Calculate elapsed time while waiting for the connection to establish. Note * that this calculation is 32-bit time overflow safe. */ connectDeltaTime = PortGet()->SystemGetTime() - connectStartTime; /* Did a timeout occur? */ if (connectDeltaTime > connectTimeout) { /* Could not connect to the target. Stop connection attempts. */ break; } } } BltSessionStop void BltSessionStop(void) Stops the firmware update session. This is there the library disconnects the transport layer as well. Note that if you are currently connected to the OpenBLT bootloader on the target microcontroller, this requests the bootloader to start the user's firmware again, if a valid one is detected by the bootloader. BltSessionClearMemory uint8_t BltSessionClearMemory(uint32_t address, uint32_t len) Requests the target to erase the specified range of memory on the target. Note that the target automatically aligns this to the erasable memory block sizes. This typically results in more memory being erased than the range that was specified here. Refer to the target implementation for details. Parameter Description address The starting memory address for the erase operation. len The total number of bytes to erase from memory. Return value TBX_OK if successful, TBX_ERROR otherwise. Example The flash memory on the ST STM32F0 microcontroller starts at address 0x08000000 and consists of 2k sectors. The following code erases the first two 2k sectors, because the OpenBLT bootloader automatically aligns to the sectors of the microcontroller's flash. BltSessionClearMemory(0x08000010, 2048); BltSessionWriteData uint8_t BltSessionWriteData(uint32_t address, uint32_t len, uint8_t const * data) Requests the target to program the specified data to memory. Note that it is the responsibility of the application to make sure the memory range was erased beforehand. Parameter Description address The starting memory address for the write operation. len The number of bytes in the data buffer that should be written. data Pointer to the byte array with data to write. Return value TBX_OK if successful, TBX_ERROR otherwise. Example This code snippet writes 16 bytes to the start of flash on an ST STM32F0 microcontroller: uint8_t writeData[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F }; BltSessionWriteData(0x08000000, 16, writeData); BltSessionReadData uint8_t BltSessionReadData(uint32_t address, uint32_t len, uint8_t * data) Requests the target to upload the specified range from memory and store its contents in the specified data buffer. Parameter Description address The starting memory address for the read operation. len The number of bytes to upload from the target and store in the data buffer. data Pointer to the byte array where the uploaded data should be stored. Return value TBX_OK if successful, TBX_ERROR otherwise. Example This code snippet reads 16 bytes from the start of flash on an ST STM32F0 microcontroller: uint8_t readData[16]; BltSessionReadData(0x08000000, 16, readData); Firmware module The firmware module embeds all the functionality for reading firmware data from a firmware file. It handles all the file parsing of for example the S-record firmware file format. The current implementation of LibMicroBLT assumes that file is present on a locally attached FAT32 file system, which the library accesses with the help of FatFs . BltFirmwareInit void BltFirmwareInit(uint8_t readerType) Initializes the firmware reader module for a specified firmware file reader. Typically called once upon application initialization. Parameter Description readerType The firmware file reader to use in this module. It should be a BLT_FIRMWARE_READER_xxx value. Example Initialize the firmware module to parse and read firmware data from S-record firmware files: BltFirmwareInit(BLT_FIRMWARE_READER_SRECORD); BltFirmwareTerminate void BltPortTerminate(void) Terminates the firmware reader module. Typically called at the end of the application when the firmware reader module is no longer needed. BltFirmwareFileOpen uint8_t BltFirmwareFileOpen(char const * firmwareFile) Opens the firmware file and browses through its contents to collect information about the firmware data segments it contains. Parameter Description firmwareFile Firmware filename including its full path. Return value TBX_OK if successful, TBX_ERROR otherwise. Example Code snippet that opens the firmware file demoprog_stm32f091.srec , stored in the firmwares directory on the SD cards' first FAT32 partition: uint8_t fileOpened = TBX_FALSE; if (BltFirmwareFileOpen(\"/firmwares/demoprog_stm32f091.srec\") == TBX_OK) { fileOpened = TBX_TRUE; } BltFirmwareFileClose void BltFirmwareFileClose(void) Closes the previously opened firmware file. BltFirmwareGetTotalSize uint32_t BltFirmwareGetTotalSize(void) Obtains the total number of data bytes present in all segments of the firmware file. You could for example use this number to track the progress of a firmware update, taking into account how many bytes you already programmed with BltSessionWriteData() . Return value Total number of firmware data bytes present in all segments of the firmware file. BltFirmwareSegmentGetCount uint8_t BltFirmwareSegmentGetCount(void) Obtains the total number of firmware data segments encountered in the firmware file. A firmware data segment consists of a consecutive block of firmware data. A firmware file always has at least one segment. However, it can have more as well. For example if there is a gap between the vector table and the other program data. Return value Total number of firmware data segments present in the firmware file. BltFirmwareSegmentGetInfo uint32_t BltFirmwareSegmentGetInfo(uint8_t idx, uint32_t * address) Obtains information about the specified segment, such as the base memory address that its data belongs to and the total number of data bytes in the segment. Parameter Description idx Zero-based segment index. Valid values are between 0 and (BltFirmwareSegmentGetCount() - 1) . address The base memory address of the segment's data is written to this pointer. Return value The total number of data bytes inside this segment. Example Code snippet that loops through all the firmware segments, obtains each segments' info and erases the related sectors in flash memory, on the connected microcontroller. This is what you need to do, before you write the data of the new firmware to flash memory. Note that error checking was left out for clarity. uint8_t segmentIdx; uint32_t segmentBase = 0U; uint32_t segmentLen; /* Erase the memory segments on the target that the firmware data covers. */ for (segmentIdx = 0U; segmentIdx < BltFirmwareSegmentGetCount(); segmentIdx++) { /* Obtain segment information such as its base memory adddress and length. */ segmentLen = BltFirmwareSegmentGetInfo(segmentIdx, &segmentBase); /* Erase the segment. */ BltSessionClearMemory(segmentBase, segmentLen); } BltFirmwareSegmentOpen void BltFirmwareSegmentOpen(uint8_t idx) Opens the firmware data segment for reading. This should always be called before calling the BltFirmwareSegmentGetNextData() function. Parameter Description idx Zero-based segment index. Valid values are between 0 and (BltFirmwareSegmentGetCount() - 1) . BltFirmwareSegmentGetNextData uint8_t const * BltFirmwareSegmentGetNextData(uint32_t * address, uint16_t * len) Obtains a data pointer to the next chunk of firmware data in the segment that was opened with function BltFirmwareSegmentOpen() . The idea is that you first open the segment and afterwards you can keep calling this function to read out the segment's firmware data. When all data is read, len will be set to zero and a non- NULL pointer is returned. Note that there are three possible outcomes when calling this function: len > 0 and a non- NULL pointer is returned. This means valid data was read. len = 0 and a non- NULL pointer is returned. This means the end of the segment is reached and therefore no new data was actually read. A NULL pointer is returned. This happens only when an error occurred. Parameter Description address The starting memory address of this chunk of firmware data is written to this pointer. len The length of the firmware data chunk is written to this pointer. Return value Data pointer to the read firmware if successful, NULL otherwise. Example Code snippet that presents a function to write the firmware data from a specific segment of the firmware file, to the flash memory on the connected microcontroller. Note that error checking was left out for clarity. void writeFirmwareSegmentToFlash(uint8_t segmentIdx) { uint8_t const * chunkData; uint16_t chunkLen = 0U; uint32_t chunkBase = 0U; /* Open the segment for reading. */ BltFirmwareSegmentOpen(segmentIdx); /* Attempt to read the first chunk of data in this segment. */ chunkData = BltFirmwareSegmentGetNextData(&chunkBase, &chunkLen); /* Enter loop to write all data chunks to flash. */ while ( (chunkData != NULL) && (chunkLen > 0U) ) { /* Program the newly read data chunk. */ BltSessionWriteData(chunkBase, chunkLen, chunkData) /* Attempt to read the next chunk of data in this segment. */ chunkData = BltFirmwareSegmentGetNextData(&chunkBase, &chunkLen); } }","title":"API reference"},{"location":"apiref/#api-reference","text":"This section provides a full reference of all the functions, macros and types that LibMicroBLT offers.","title":"API reference"},{"location":"apiref/#macros","text":"Macro Description BLT_VERSION_MAIN Main version number of LibMicroBLT. BLT_VERSION_MINOR Minor version number of LibMicroBLT. BLT_VERSION_PATCH Patch number of LibMicroBLT. BLT_SESSION_XCP_V10 Session type identifier for XCP version 1.0. BLT_FIRMWARE_READER_SRECORD Firmware type identifier for S-record firmware files.","title":"Macros"},{"location":"apiref/#types","text":"","title":"Types"},{"location":"apiref/#tbltsessionsettingsxcpv10","text":"typedef struct tBltSessionSettingsXcpV10 Structure layout of the XCP version 1.0 session settings. Element Description timeoutT1 Command response timeout in milliseconds. timeoutT3 Start programming timeout in milliseconds. timeoutT4 Erase memory timeout in milliseconds. timeoutT5 Program memory and reset timeout in milliseconds. timeoutT6 Connect response timeout in milliseconds. timeoutT7 Busy wait timer timeout in milliseonds. connectMode Connection mode parameter in XCP connect command.","title":"tBltSessionSettingsXcpV10"},{"location":"apiref/#tportxcppacket","text":"typedef struct tPortXcpPacket XCP packet type. Element Description data Byte array with packet data. len Number of data bytes stored in the packet.","title":"tPortXcpPacket"},{"location":"apiref/#tport","text":"typedef struct tPort Port interface. The port interface links the hardware specific implementation to the hardware independent library. Element Description SystemGetTime Function pointer to obtain the current system time in milliseconds. XcpTransmitPacket Function pointer to transmit an XCP packet using the transport layer implemented by the port. The transmission itself can be blocking. The function should return TBX_OK if the packet could be transmitted, TBX_ERROR otherwise. XcpReceivePacket Function pointer to receive an XCP packet using the transport layer implemented by the port. The reception should be non-blocking. The function should return TBX_TRUE if a packet was received, TBX_FALSE otherwise. A newly received packet should be stored in the rxPacket parameter. XcpComputeKeyFromSeed Function pointer to calculates the key to unlock the programming resource, based on the given seed. This function should return TBX_OK if the key could be calculated, TBX_ERROR otherwise. Note that it's okay to set this element to NULL , if you do not use the seed/key security feature of the OpenBLT bootloader.","title":"tPort"},{"location":"apiref/#functions","text":"","title":"Functions"},{"location":"apiref/#port-module","text":"The port module makes it possible to connect your hardware specifics to the hardware independent LibMicroBLT library. In your own application you implement the port specific functions. For example for transmitting and receiving XCP communication packet on the transport layer of your choice. You then specify your port specific functions in a variable of type tPort . You pass this variable on as a parameter when calling function BltPortInit() , which links your hardware specifics to LibMicroBLT. For this reason, you should first call function BltPortInit() , before calling any other functions of LibMicroBLT.","title":"Port module"},{"location":"apiref/#bltportinit","text":"void BltPortInit(tPort const * port) Initializes the port module by linking the port specified by the parameter. Typically called once during firmware initialization. Must be called before calling any other functions of LibMicroBLT. Parameter Description port Pointer to the port to link (type tPort ). Example This example is taken from the LibMicroBLT demo application, where the application implements the hardware specific functions in: AppPortSystemGetTime() AppPortXcpTransmitPacket() AppPortXcpReceivePacket() AppPortXcpComputeKeyFromSeed() Refer to the LibMicroBLT demo application for an example on how to implement or port these functions for your own hardware. Once these port functions are implemented, you link them to LibMicroBLT like this: tPort const portInterface = { .SystemGetTime = AppPortSystemGetTime, .XcpTransmitPacket = AppPortXcpTransmitPacket, .XcpReceivePacket = AppPortXcpReceivePacket, .XcpComputeKeyFromSeed = AppPortXcpComputeKeyFromSeed }; BltPortInit(&portInterface);","title":"BltPortInit"},{"location":"apiref/#bltportterminate","text":"void BltPortTerminate(void) Terminates the port module. Typically called once during firmware exit. Embedded firmware tends to be driven by an infinite program loop and never exits. In such cases, you can omit calling this function.","title":"BltPortTerminate"},{"location":"apiref/#session-module","text":"The session module implements all the functionality for communicating with the OpenBLT bootloader running the other microcontroller(s); The ones on which you want to perform a firmware update from the microcontroller that runs this LibMicroBLT library. The functionality of the session module encompasses: Connect and disconnect. Erase, write and read memory.","title":"Session module"},{"location":"apiref/#bltsessioninit","text":"void BltSessionInit(uint32_t type, void const * settings) Initializes the firmware update session for a specific communication protocol. This function is typically called at the start of the firmware update. Parameter Description type The communication protocol to use for this session. It should be a BLT_SESSION_xxx value. settings Pointer to a structure with communication protocol specific settings. Example Initialize the session module for communication using the XCP version 1.0 protocol: tBltSessionSettingsXcpV10 const sessionSettings = { .timeoutT1 = 1000U, .timeoutT3 = 2000U, .timeoutT4 = 10000U, .timeoutT5 = 1000U, .timeoutT6 = 50U, .timeoutT7 = 2000U, .connectMode = 0 }; BltSessionInit(BLT_SESSION_XCP_V10, &sessionSettings);","title":"BltSessionInit"},{"location":"apiref/#bltsessionterminate","text":"void BltSessionTerminate(void) Terminates the firmware update session. This function is typically called at the end of the firmware update.","title":"BltSessionTerminate"},{"location":"apiref/#bltsessionstart","text":"uint8_t BltSessionStart(void) Starts the firmware update session. This is were the library attempts to activate and connect with the bootloader running on the target, through the transport layer that was specified during the session's initialization. Return value TBX_OK if successful, TBX_ERROR otherwise. Example When attempting to connect to the OpenBLT bootloader on the target microcontroller, the bootloader itself is often not yet active. Instead, the user's firmware is happily running. The firmware typically includes functionality to receive the connection request, after which it activates the bootloader by performing a software reset. If this functionality is not present, the user needs to manually reset the microcontroller. It's therefore recommended to try connecting to the OpenBLT bootloader, by calling BltSessionStart() repeatedly for a finite amount of time. Note that the following example also demonstrates how your own application can access the port specific functions: uint32_t const connectTimeout = 5000U; uint32_t connectStartTime; uint32_t connectDeltaTime; uint8_t connected = TBX_FALSE; /* Store start time. */ connectStartTime = PortGet()->SystemGetTime(); /* Attempt to connect to the target. */ connected = BltSessionStart(); /* Repeat connection attempt for a finite amount of time. */ while (connected == TBX_FALSE) { /* Attempt to connect to the target. */ connected = BltSessionStart(); /* Handle timeout detection if not yet connected. */ if (connected == TBX_FALSE) { /* Calculate elapsed time while waiting for the connection to establish. Note * that this calculation is 32-bit time overflow safe. */ connectDeltaTime = PortGet()->SystemGetTime() - connectStartTime; /* Did a timeout occur? */ if (connectDeltaTime > connectTimeout) { /* Could not connect to the target. Stop connection attempts. */ break; } } }","title":"BltSessionStart"},{"location":"apiref/#bltsessionstop","text":"void BltSessionStop(void) Stops the firmware update session. This is there the library disconnects the transport layer as well. Note that if you are currently connected to the OpenBLT bootloader on the target microcontroller, this requests the bootloader to start the user's firmware again, if a valid one is detected by the bootloader.","title":"BltSessionStop"},{"location":"apiref/#bltsessionclearmemory","text":"uint8_t BltSessionClearMemory(uint32_t address, uint32_t len) Requests the target to erase the specified range of memory on the target. Note that the target automatically aligns this to the erasable memory block sizes. This typically results in more memory being erased than the range that was specified here. Refer to the target implementation for details. Parameter Description address The starting memory address for the erase operation. len The total number of bytes to erase from memory. Return value TBX_OK if successful, TBX_ERROR otherwise. Example The flash memory on the ST STM32F0 microcontroller starts at address 0x08000000 and consists of 2k sectors. The following code erases the first two 2k sectors, because the OpenBLT bootloader automatically aligns to the sectors of the microcontroller's flash. BltSessionClearMemory(0x08000010, 2048);","title":"BltSessionClearMemory"},{"location":"apiref/#bltsessionwritedata","text":"uint8_t BltSessionWriteData(uint32_t address, uint32_t len, uint8_t const * data) Requests the target to program the specified data to memory. Note that it is the responsibility of the application to make sure the memory range was erased beforehand. Parameter Description address The starting memory address for the write operation. len The number of bytes in the data buffer that should be written. data Pointer to the byte array with data to write. Return value TBX_OK if successful, TBX_ERROR otherwise. Example This code snippet writes 16 bytes to the start of flash on an ST STM32F0 microcontroller: uint8_t writeData[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F }; BltSessionWriteData(0x08000000, 16, writeData);","title":"BltSessionWriteData"},{"location":"apiref/#bltsessionreaddata","text":"uint8_t BltSessionReadData(uint32_t address, uint32_t len, uint8_t * data) Requests the target to upload the specified range from memory and store its contents in the specified data buffer. Parameter Description address The starting memory address for the read operation. len The number of bytes to upload from the target and store in the data buffer. data Pointer to the byte array where the uploaded data should be stored. Return value TBX_OK if successful, TBX_ERROR otherwise. Example This code snippet reads 16 bytes from the start of flash on an ST STM32F0 microcontroller: uint8_t readData[16]; BltSessionReadData(0x08000000, 16, readData);","title":"BltSessionReadData"},{"location":"apiref/#firmware-module","text":"The firmware module embeds all the functionality for reading firmware data from a firmware file. It handles all the file parsing of for example the S-record firmware file format. The current implementation of LibMicroBLT assumes that file is present on a locally attached FAT32 file system, which the library accesses with the help of FatFs .","title":"Firmware module"},{"location":"apiref/#bltfirmwareinit","text":"void BltFirmwareInit(uint8_t readerType) Initializes the firmware reader module for a specified firmware file reader. Typically called once upon application initialization. Parameter Description readerType The firmware file reader to use in this module. It should be a BLT_FIRMWARE_READER_xxx value. Example Initialize the firmware module to parse and read firmware data from S-record firmware files: BltFirmwareInit(BLT_FIRMWARE_READER_SRECORD);","title":"BltFirmwareInit"},{"location":"apiref/#bltfirmwareterminate","text":"void BltPortTerminate(void) Terminates the firmware reader module. Typically called at the end of the application when the firmware reader module is no longer needed.","title":"BltFirmwareTerminate"},{"location":"apiref/#bltfirmwarefileopen","text":"uint8_t BltFirmwareFileOpen(char const * firmwareFile) Opens the firmware file and browses through its contents to collect information about the firmware data segments it contains. Parameter Description firmwareFile Firmware filename including its full path. Return value TBX_OK if successful, TBX_ERROR otherwise. Example Code snippet that opens the firmware file demoprog_stm32f091.srec , stored in the firmwares directory on the SD cards' first FAT32 partition: uint8_t fileOpened = TBX_FALSE; if (BltFirmwareFileOpen(\"/firmwares/demoprog_stm32f091.srec\") == TBX_OK) { fileOpened = TBX_TRUE; }","title":"BltFirmwareFileOpen"},{"location":"apiref/#bltfirmwarefileclose","text":"void BltFirmwareFileClose(void) Closes the previously opened firmware file.","title":"BltFirmwareFileClose"},{"location":"apiref/#bltfirmwaregettotalsize","text":"uint32_t BltFirmwareGetTotalSize(void) Obtains the total number of data bytes present in all segments of the firmware file. You could for example use this number to track the progress of a firmware update, taking into account how many bytes you already programmed with BltSessionWriteData() . Return value Total number of firmware data bytes present in all segments of the firmware file.","title":"BltFirmwareGetTotalSize"},{"location":"apiref/#bltfirmwaresegmentgetcount","text":"uint8_t BltFirmwareSegmentGetCount(void) Obtains the total number of firmware data segments encountered in the firmware file. A firmware data segment consists of a consecutive block of firmware data. A firmware file always has at least one segment. However, it can have more as well. For example if there is a gap between the vector table and the other program data. Return value Total number of firmware data segments present in the firmware file.","title":"BltFirmwareSegmentGetCount"},{"location":"apiref/#bltfirmwaresegmentgetinfo","text":"uint32_t BltFirmwareSegmentGetInfo(uint8_t idx, uint32_t * address) Obtains information about the specified segment, such as the base memory address that its data belongs to and the total number of data bytes in the segment. Parameter Description idx Zero-based segment index. Valid values are between 0 and (BltFirmwareSegmentGetCount() - 1) . address The base memory address of the segment's data is written to this pointer. Return value The total number of data bytes inside this segment. Example Code snippet that loops through all the firmware segments, obtains each segments' info and erases the related sectors in flash memory, on the connected microcontroller. This is what you need to do, before you write the data of the new firmware to flash memory. Note that error checking was left out for clarity. uint8_t segmentIdx; uint32_t segmentBase = 0U; uint32_t segmentLen; /* Erase the memory segments on the target that the firmware data covers. */ for (segmentIdx = 0U; segmentIdx < BltFirmwareSegmentGetCount(); segmentIdx++) { /* Obtain segment information such as its base memory adddress and length. */ segmentLen = BltFirmwareSegmentGetInfo(segmentIdx, &segmentBase); /* Erase the segment. */ BltSessionClearMemory(segmentBase, segmentLen); }","title":"BltFirmwareSegmentGetInfo"},{"location":"apiref/#bltfirmwaresegmentopen","text":"void BltFirmwareSegmentOpen(uint8_t idx) Opens the firmware data segment for reading. This should always be called before calling the BltFirmwareSegmentGetNextData() function. Parameter Description idx Zero-based segment index. Valid values are between 0 and (BltFirmwareSegmentGetCount() - 1) .","title":"BltFirmwareSegmentOpen"},{"location":"apiref/#bltfirmwaresegmentgetnextdata","text":"uint8_t const * BltFirmwareSegmentGetNextData(uint32_t * address, uint16_t * len) Obtains a data pointer to the next chunk of firmware data in the segment that was opened with function BltFirmwareSegmentOpen() . The idea is that you first open the segment and afterwards you can keep calling this function to read out the segment's firmware data. When all data is read, len will be set to zero and a non- NULL pointer is returned. Note that there are three possible outcomes when calling this function: len > 0 and a non- NULL pointer is returned. This means valid data was read. len = 0 and a non- NULL pointer is returned. This means the end of the segment is reached and therefore no new data was actually read. A NULL pointer is returned. This happens only when an error occurred. Parameter Description address The starting memory address of this chunk of firmware data is written to this pointer. len The length of the firmware data chunk is written to this pointer. Return value Data pointer to the read firmware if successful, NULL otherwise. Example Code snippet that presents a function to write the firmware data from a specific segment of the firmware file, to the flash memory on the connected microcontroller. Note that error checking was left out for clarity. void writeFirmwareSegmentToFlash(uint8_t segmentIdx) { uint8_t const * chunkData; uint16_t chunkLen = 0U; uint32_t chunkBase = 0U; /* Open the segment for reading. */ BltFirmwareSegmentOpen(segmentIdx); /* Attempt to read the first chunk of data in this segment. */ chunkData = BltFirmwareSegmentGetNextData(&chunkBase, &chunkLen); /* Enter loop to write all data chunks to flash. */ while ( (chunkData != NULL) && (chunkLen > 0U) ) { /* Program the newly read data chunk. */ BltSessionWriteData(chunkBase, chunkLen, chunkData) /* Attempt to read the next chunk of data in this segment. */ chunkData = BltFirmwareSegmentGetNextData(&chunkBase, &chunkLen); } }","title":"BltFirmwareSegmentGetNextData"},{"location":"demo/","text":"LibMicroBLT demo application Integrating a new software component into your own firmware is always easier, if you have a fully functional and preconfigured example to refer to. For this purpose a demo application was added to the LibMicroBLT software package. This section explains how to get the demo application up-and-running. Note that there's no need to actually do this yourself. You can alternatively inspect the source of the demo application, to get a feel for how to use LibMicroBLT in your own firmware. System setup The demo application consists of firmware for the Olimex STM32-P405 board. This board acts as the main controller, which has LibMicroBLT integrated. It is capable of performing a firmware update on another microcontroller, that runs the OpenBLT bootloader, connected via a CAN bus. It reads the firmware file in the S-record format, from the FAT32 file system on an attached SD card. As the target node, so the one that gets its firmware updated, you can use any of the OpenBLT demo programs , configured to support firmware updates via CAN. The remainder of this section assumes an ST Nucleo-F091RC board was selected for the target node. Since this board does not feature a CAN transceiver, a Waveshare RS485/CAN shield was attached. System preparation Assuming that you use the same boards, prepare the system as follows: Connect both boards to a CAN bus with proper 120 Ohm line termination resistors. Connect an ST-Link debugger interface to the Olimex STM32-P405 board. Power up both boards. Flash the openblt_stm32f091.srec OpenBLT demo bootloader onto the ST Nucleo-F091RC board. Store the demoprog_stm32f091.srec OpenBLT demo user program for the ST Nucleo-F091RC board on the SD card. Insert the SD card into the Olimex STM32-P405 board. Build, flash and run the demo application With the system prepared, you just need to build, flash and run the demo application. The demo application was developed with the STM32CubeIDE development environment. Start STM32CubeIDE, create a new workspace and import the demo application. The demo application is located in: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/ Once imported, build the firmware of the demo application by selecting Project \u2192 Build Project from the STM32CubeIDE menu. This creates the firmware file: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/Debug/Demo.elf Start a debugger session to flash this firmware onto the Olimex STM32-P405 board. You can run the demo application using the debugger directly. Alternatively, you can close the debugger session and hit the reset button on the board the run the demo application. Perform a firmware update To start the firmware update, press the big black push-button on the Olimex STM32-P405 board. The demo application then looks for a file in the root directory on the SD card, which starts with demoprog and ends with .srec . In our case, this means it finds the file demoprog_stm32f091.srec on the SD-card. Note that this part is done with the help of function AppLocateFirmwareFile() . After detecting the demoprog_stm32f091.srec on the SD card, the demo application starts the firmware update procedure by calling function UpdateFirmware() . This function uses the LibMicroBLT API to: Initialize the Firmware and Session modules. Open and parse the demoprog_stm32f091.srec firmware file on the SD card. Connect to the bootloader on the Nucleo-F091RC board via the CAN bus. Erase the flash memory segments that should be reprogrammed. Read the new firmware data from the firmware file and program it to the flash memory. Disconnect from the bootloader on the Nucleo-F091RC, which also automatically starts the newly programmed firmware. Close the firmware file. Terminate the Firmware and Session modules. A closer look The logic for the actual firmware update procedure is implemented in function UpdateFirmware() in source file: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/App/update.c It was developed such that you can reuse this source file and function UpdateFirmware() in your own firmware. The task that drives the demo application is called AppTask() and is located in source file: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/App/app.c For detecting the firmware file on the SD card, you can take function AppLocateFirmwareFile() as a starting point. You just need to modify it such that it looks for the filename or filename pattern that you decided on for your firmware files. The demo application builds on the FreeRTOS real-time operating system. However, this is not mandatory for LibMicroBLT. You can use whatever operating system you prefer, even if it's a basic super loop that drives your firmware. Note that the demo application showcases how to leverage MicroTBX's memory pools for FreeRTOS' heap management. Feel free to reuse it in your own firmware: demos/third_party/microtbx/source/extra/freertos/tbxfreertos.c","title":"Demo application"},{"location":"demo/#libmicroblt-demo-application","text":"Integrating a new software component into your own firmware is always easier, if you have a fully functional and preconfigured example to refer to. For this purpose a demo application was added to the LibMicroBLT software package. This section explains how to get the demo application up-and-running. Note that there's no need to actually do this yourself. You can alternatively inspect the source of the demo application, to get a feel for how to use LibMicroBLT in your own firmware.","title":"LibMicroBLT demo application"},{"location":"demo/#system-setup","text":"The demo application consists of firmware for the Olimex STM32-P405 board. This board acts as the main controller, which has LibMicroBLT integrated. It is capable of performing a firmware update on another microcontroller, that runs the OpenBLT bootloader, connected via a CAN bus. It reads the firmware file in the S-record format, from the FAT32 file system on an attached SD card. As the target node, so the one that gets its firmware updated, you can use any of the OpenBLT demo programs , configured to support firmware updates via CAN. The remainder of this section assumes an ST Nucleo-F091RC board was selected for the target node. Since this board does not feature a CAN transceiver, a Waveshare RS485/CAN shield was attached.","title":"System setup"},{"location":"demo/#system-preparation","text":"Assuming that you use the same boards, prepare the system as follows: Connect both boards to a CAN bus with proper 120 Ohm line termination resistors. Connect an ST-Link debugger interface to the Olimex STM32-P405 board. Power up both boards. Flash the openblt_stm32f091.srec OpenBLT demo bootloader onto the ST Nucleo-F091RC board. Store the demoprog_stm32f091.srec OpenBLT demo user program for the ST Nucleo-F091RC board on the SD card. Insert the SD card into the Olimex STM32-P405 board.","title":"System preparation"},{"location":"demo/#build-flash-and-run-the-demo-application","text":"With the system prepared, you just need to build, flash and run the demo application. The demo application was developed with the STM32CubeIDE development environment. Start STM32CubeIDE, create a new workspace and import the demo application. The demo application is located in: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/ Once imported, build the firmware of the demo application by selecting Project \u2192 Build Project from the STM32CubeIDE menu. This creates the firmware file: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/Debug/Demo.elf Start a debugger session to flash this firmware onto the Olimex STM32-P405 board. You can run the demo application using the debugger directly. Alternatively, you can close the debugger session and hit the reset button on the board the run the demo application.","title":"Build, flash and run the demo application"},{"location":"demo/#perform-a-firmware-update","text":"To start the firmware update, press the big black push-button on the Olimex STM32-P405 board. The demo application then looks for a file in the root directory on the SD card, which starts with demoprog and ends with .srec . In our case, this means it finds the file demoprog_stm32f091.srec on the SD-card. Note that this part is done with the help of function AppLocateFirmwareFile() . After detecting the demoprog_stm32f091.srec on the SD card, the demo application starts the firmware update procedure by calling function UpdateFirmware() . This function uses the LibMicroBLT API to: Initialize the Firmware and Session modules. Open and parse the demoprog_stm32f091.srec firmware file on the SD card. Connect to the bootloader on the Nucleo-F091RC board via the CAN bus. Erase the flash memory segments that should be reprogrammed. Read the new firmware data from the firmware file and program it to the flash memory. Disconnect from the bootloader on the Nucleo-F091RC, which also automatically starts the newly programmed firmware. Close the firmware file. Terminate the Firmware and Session modules.","title":"Perform a firmware update"},{"location":"demo/#a-closer-look","text":"The logic for the actual firmware update procedure is implemented in function UpdateFirmware() in source file: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/App/update.c It was developed such that you can reuse this source file and function UpdateFirmware() in your own firmware. The task that drives the demo application is called AppTask() and is located in source file: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/App/app.c For detecting the firmware file on the SD card, you can take function AppLocateFirmwareFile() as a starting point. You just need to modify it such that it looks for the filename or filename pattern that you decided on for your firmware files. The demo application builds on the FreeRTOS real-time operating system. However, this is not mandatory for LibMicroBLT. You can use whatever operating system you prefer, even if it's a basic super loop that drives your firmware. Note that the demo application showcases how to leverage MicroTBX's memory pools for FreeRTOS' heap management. Feel free to reuse it in your own firmware: demos/third_party/microtbx/source/extra/freertos/tbxfreertos.c","title":"A closer look"},{"location":"getting_started/","text":"Getting started with LibMicroBLT This section explains step-by-step how to get LibMicroBLT integrated and operational in your own firmware. Getting the code The first step is getting the code. Two options exists: Download the latest stable release from GitHub: https://github.com/feaser/libmicroblt/releases Clone the development version from GitHub: git clone https://github.com/feaser/libmicroblt.git git submodule update --init Option 1 is the recommended option. Option 2 is only needed, when you want to participate in the development. For example by submitting a pull request. Integrate MicroTBX and FatFS As shown in the presentation of the LibMicroBLT architecture , this library depends on two third-party components: Feaser's own MicroTBX - Generic microcontroller software toolbox. ELM's FatFS - For accessing a FAT32 file system. Start by integrating these two modules into your firmware. The LibMicroBLT package includes both components, meaning that you can copy the source code from there: Refer to the MicroTBX and FatFS websites for detailed instructions on how to integrate these components into your firmware. Alternatively, you can refer to the demo application that's included in the LibMicroBLT package. Integrate LibMicroBLT After integrating the third-party component dependencies, continue with the actual integration of LibMicroBLT's sources. You can find these in the source directory: Copy all the files from the source directory to your firmware's project. Configure your project such that the added .c files are compiled and linked during a build. Add the directory that contains the added .h files to your compiler's include path. In all .c source files, where you plan on using LibMicroBLT related functionality, include the library's API header-file: #include <microblt.h> Add port function placeholders The LibMicroBLT code itself is hardware independent. However, it does need access to some of your microcontroller's peripherals. For example for a time reference and for the communication with the other microcontroller, which runs the OpenBLT bootloader. You can implement these hardware specifics in port functions, which we'll link to LibMicroBLT in the next section. Start by adding empty placeholders for these port functions: /************************************************************************************//** ** \\brief Obtains the current system time in milliseconds. ** \\return Current system time in milliseconds. ** ****************************************************************************************/ uint32_t AppPortSystemGetTime(void) { /* TODO Obtain the current value of the millisecond timer. */ return TimerGet(); } /*** end of AppPortSystemGetTime ***/ /************************************************************************************//** ** \\brief Transmits an XCP packet using the transport layer implemented by the port. ** The transmission itself can be blocking. ** \\param txPacket The XCP packet to transmit using the application's transport layer ** of choice. ** \\return TBX_OK if the packet could be transmitted, TBX_ERROR otherwise. ** ****************************************************************************************/ uint8_t AppPortXcpTransmitPacket(tPortXcpPacket const * txPacket) { uint8_t result = TBX_ERROR; /* Verify parameter. */ TBX_ASSERT(txPacket != NULL); /* Only continue with valid parameter. */ if (txPacket != NULL) { /* TODO Transmit the txPacket. */ result = TBX_OK; } /* Give the result back to the caller. */ return result; } /*** end of AppPortXcpTransmitPacket ***/ /************************************************************************************//** ** \\brief Attempts to receive an XCP packet using the transport layer implemented by ** the port. The reception should be non-blocking. ** \\param rxPacket Structure where the newly received XCP packet should be stored. ** \\return TBX_TRUE if a packet was received, TBX_FALSE otherwise. ** ****************************************************************************************/ uint8_t AppPortXcpReceivePacket(tPortXcpPacket * rxPacket) { uint8_t result = TBX_FALSE; /* Verify parameter. */ TBX_ASSERT(rxPacket != NULL); /* Only continue with valid parameter. */ if (rxPacket != NULL) { /* TODO Check if a new XCP packet was received and store it in rxPacket. */ result = TBX_TRUE; } /* Give the result back to the caller. */ return result; } /*** end of AppPortXcpReceivePacket ****/ /************************************************************************************//** ** \\brief Computes the key for the programming resource. ** \\param seedLen length of the seed ** \\param seedPtr pointer to the seed data ** \\param keyLenPtr pointer where to store the key length ** \\param keyPtr pointer where to store the key data ** \\return TBX_OK if the key could be calculated, TBX_ERROR otherwise. ** ****************************************************************************************/ uint8_t AppPortXcpComputeKeyFromSeed(uint8_t seedLen, uint8_t const * seedPtr, uint8_t * keyLenPtr, uint8_t * keyPtr) { uint8_t result = TBX_FALSE; /* Verify parameters. */ TBX_ASSERT((seedLen > 0U) && (seedPtr != NULL) && (keyLenPtr != NULL) && (keyPtr != NULL)); /* Only continue with valid parameters. */ if ((seedLen > 0U) && (seedPtr != NULL) && (keyLenPtr != NULL) && (keyPtr != NULL)) { /* TODO Compute the key, store it in the keyPtr byte array and set its length in * keyLenPtr. */ result = TBX_OK; } /* Give the result back to the caller. */ return result; } /*** end of AppPortXcpComputeKeyFromSeed ***/ Add them to whichever source file makes the most sense, based on your preferred source code organization. You can of course rename these functions to match your code's naming convention. Library initialization When initializing your firmware, make sure to first link your port functions by initializing the port module and mount your FAT32 partition. This should be done before you enter your firmware's infinite program loop, e.g. start your RTOS scheduler, and before you call any of the other LibMicroBLT API functions: tPort const portInterface = { .SystemGetTime = AppPortSystemGetTime, .XcpTransmitPacket = AppPortXcpTransmitPacket, .XcpReceivePacket = AppPortXcpReceivePacket, .XcpComputeKeyFromSeed = AppPortXcpComputeKeyFromSeed }; /* Initialize the port module for linking the hardware dependent parts. */ BltPortInit(&portInterface); /* Mount the file system, using logical disk 0 */ f_mount(&fileSystem, \"0:\", 0U); Implement the port functions The final integration step involves implementing the port functions to work with your microcontroller and preferred communication transport layer for firmware updates. You can find a fully functional version of these port functions in the demo application . It assumes CAN communication between LibMicroBLT and the other microcontroller, which runs the OpenBLT bootloader. If you selected a different communication transport layer for firmware updates (RS232, Modbus RTU, etc.), you can look at the OpenBLT code base on how the bootloader expects the XCP packets to be formatted for your transport layer. Firmware update procedure Once you made it to this point, LibMicroBLT is fully operational and you can use it to perform firmware updates on the connected microcontroller node(s), running the OpenBLT bootloader. The demo application contains a reusable function for this. It's called: uint8_t UpdateFirmware(char const * firmwareFile, uint8_t nodeId) Feel free to copy it to your own firmware. You can find it in: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/App/update.c The following flowchart further explains the firmware update procedure, using LibMicroBLT:","title":"Getting started"},{"location":"getting_started/#getting-started-with-libmicroblt","text":"This section explains step-by-step how to get LibMicroBLT integrated and operational in your own firmware.","title":"Getting started with LibMicroBLT"},{"location":"getting_started/#getting-the-code","text":"The first step is getting the code. Two options exists: Download the latest stable release from GitHub: https://github.com/feaser/libmicroblt/releases Clone the development version from GitHub: git clone https://github.com/feaser/libmicroblt.git git submodule update --init Option 1 is the recommended option. Option 2 is only needed, when you want to participate in the development. For example by submitting a pull request.","title":"Getting the code"},{"location":"getting_started/#integrate-microtbx-and-fatfs","text":"As shown in the presentation of the LibMicroBLT architecture , this library depends on two third-party components: Feaser's own MicroTBX - Generic microcontroller software toolbox. ELM's FatFS - For accessing a FAT32 file system. Start by integrating these two modules into your firmware. The LibMicroBLT package includes both components, meaning that you can copy the source code from there: Refer to the MicroTBX and FatFS websites for detailed instructions on how to integrate these components into your firmware. Alternatively, you can refer to the demo application that's included in the LibMicroBLT package.","title":"Integrate MicroTBX and FatFS"},{"location":"getting_started/#integrate-libmicroblt","text":"After integrating the third-party component dependencies, continue with the actual integration of LibMicroBLT's sources. You can find these in the source directory: Copy all the files from the source directory to your firmware's project. Configure your project such that the added .c files are compiled and linked during a build. Add the directory that contains the added .h files to your compiler's include path. In all .c source files, where you plan on using LibMicroBLT related functionality, include the library's API header-file: #include <microblt.h>","title":"Integrate LibMicroBLT"},{"location":"getting_started/#add-port-function-placeholders","text":"The LibMicroBLT code itself is hardware independent. However, it does need access to some of your microcontroller's peripherals. For example for a time reference and for the communication with the other microcontroller, which runs the OpenBLT bootloader. You can implement these hardware specifics in port functions, which we'll link to LibMicroBLT in the next section. Start by adding empty placeholders for these port functions: /************************************************************************************//** ** \\brief Obtains the current system time in milliseconds. ** \\return Current system time in milliseconds. ** ****************************************************************************************/ uint32_t AppPortSystemGetTime(void) { /* TODO Obtain the current value of the millisecond timer. */ return TimerGet(); } /*** end of AppPortSystemGetTime ***/ /************************************************************************************//** ** \\brief Transmits an XCP packet using the transport layer implemented by the port. ** The transmission itself can be blocking. ** \\param txPacket The XCP packet to transmit using the application's transport layer ** of choice. ** \\return TBX_OK if the packet could be transmitted, TBX_ERROR otherwise. ** ****************************************************************************************/ uint8_t AppPortXcpTransmitPacket(tPortXcpPacket const * txPacket) { uint8_t result = TBX_ERROR; /* Verify parameter. */ TBX_ASSERT(txPacket != NULL); /* Only continue with valid parameter. */ if (txPacket != NULL) { /* TODO Transmit the txPacket. */ result = TBX_OK; } /* Give the result back to the caller. */ return result; } /*** end of AppPortXcpTransmitPacket ***/ /************************************************************************************//** ** \\brief Attempts to receive an XCP packet using the transport layer implemented by ** the port. The reception should be non-blocking. ** \\param rxPacket Structure where the newly received XCP packet should be stored. ** \\return TBX_TRUE if a packet was received, TBX_FALSE otherwise. ** ****************************************************************************************/ uint8_t AppPortXcpReceivePacket(tPortXcpPacket * rxPacket) { uint8_t result = TBX_FALSE; /* Verify parameter. */ TBX_ASSERT(rxPacket != NULL); /* Only continue with valid parameter. */ if (rxPacket != NULL) { /* TODO Check if a new XCP packet was received and store it in rxPacket. */ result = TBX_TRUE; } /* Give the result back to the caller. */ return result; } /*** end of AppPortXcpReceivePacket ****/ /************************************************************************************//** ** \\brief Computes the key for the programming resource. ** \\param seedLen length of the seed ** \\param seedPtr pointer to the seed data ** \\param keyLenPtr pointer where to store the key length ** \\param keyPtr pointer where to store the key data ** \\return TBX_OK if the key could be calculated, TBX_ERROR otherwise. ** ****************************************************************************************/ uint8_t AppPortXcpComputeKeyFromSeed(uint8_t seedLen, uint8_t const * seedPtr, uint8_t * keyLenPtr, uint8_t * keyPtr) { uint8_t result = TBX_FALSE; /* Verify parameters. */ TBX_ASSERT((seedLen > 0U) && (seedPtr != NULL) && (keyLenPtr != NULL) && (keyPtr != NULL)); /* Only continue with valid parameters. */ if ((seedLen > 0U) && (seedPtr != NULL) && (keyLenPtr != NULL) && (keyPtr != NULL)) { /* TODO Compute the key, store it in the keyPtr byte array and set its length in * keyLenPtr. */ result = TBX_OK; } /* Give the result back to the caller. */ return result; } /*** end of AppPortXcpComputeKeyFromSeed ***/ Add them to whichever source file makes the most sense, based on your preferred source code organization. You can of course rename these functions to match your code's naming convention.","title":"Add port function placeholders"},{"location":"getting_started/#library-initialization","text":"When initializing your firmware, make sure to first link your port functions by initializing the port module and mount your FAT32 partition. This should be done before you enter your firmware's infinite program loop, e.g. start your RTOS scheduler, and before you call any of the other LibMicroBLT API functions: tPort const portInterface = { .SystemGetTime = AppPortSystemGetTime, .XcpTransmitPacket = AppPortXcpTransmitPacket, .XcpReceivePacket = AppPortXcpReceivePacket, .XcpComputeKeyFromSeed = AppPortXcpComputeKeyFromSeed }; /* Initialize the port module for linking the hardware dependent parts. */ BltPortInit(&portInterface); /* Mount the file system, using logical disk 0 */ f_mount(&fileSystem, \"0:\", 0U);","title":"Library initialization"},{"location":"getting_started/#implement-the-port-functions","text":"The final integration step involves implementing the port functions to work with your microcontroller and preferred communication transport layer for firmware updates. You can find a fully functional version of these port functions in the demo application . It assumes CAN communication between LibMicroBLT and the other microcontroller, which runs the OpenBLT bootloader. If you selected a different communication transport layer for firmware updates (RS232, Modbus RTU, etc.), you can look at the OpenBLT code base on how the bootloader expects the XCP packets to be formatted for your transport layer.","title":"Implement the port functions"},{"location":"getting_started/#firmware-update-procedure","text":"Once you made it to this point, LibMicroBLT is fully operational and you can use it to perform firmware updates on the connected microcontroller node(s), running the OpenBLT bootloader. The demo application contains a reusable function for this. It's called: uint8_t UpdateFirmware(char const * firmwareFile, uint8_t nodeId) Feel free to copy it to your own firmware. You can find it in: demos/ARMCM4_STM32F4_Olimex_STM32P405_CubeIDE/App/update.c The following flowchart further explains the firmware update procedure, using LibMicroBLT:","title":"Firmware update procedure"},{"location":"license/","text":"License LibMicroBLT is released under the MIT license. This permissive license enables you to include and distribute LibMicroBLT with your firmware, even if it is proprietary. Refer to the following table for answers to frequently asked questions regarding the MIT license. Question MIT license Is LibMicroBLT free? yes Do I have the right to change the LibMicroBLT source code? yes Can I use LibMicroBLT in my closed source product? yes Do I have to open my source code? no Do I have to open source my changes to LibMicroBLT? no Do I have to offer the LibMicroBLT source code to users of my product? no Do I have to document that my product uses LibMicroBLT? no Can I redistribute LibMicroBLT in source code format? yes Can I receive professional technical support on a commercial basis? yes The actual license text is as follows: /*--------------------------------------------------------------------------------------- * C O P Y R I G H T *---------------------------------------------------------------------------------------- * Copyright (c) 2022 by Feaser www.feaser.com All rights reserved * *---------------------------------------------------------------------------------------- * L I C E N S E *---------------------------------------------------------------------------------------- * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */","title":"License"},{"location":"license/#license","text":"LibMicroBLT is released under the MIT license. This permissive license enables you to include and distribute LibMicroBLT with your firmware, even if it is proprietary. Refer to the following table for answers to frequently asked questions regarding the MIT license. Question MIT license Is LibMicroBLT free? yes Do I have the right to change the LibMicroBLT source code? yes Can I use LibMicroBLT in my closed source product? yes Do I have to open my source code? no Do I have to open source my changes to LibMicroBLT? no Do I have to offer the LibMicroBLT source code to users of my product? no Do I have to document that my product uses LibMicroBLT? no Can I redistribute LibMicroBLT in source code format? yes Can I receive professional technical support on a commercial basis? yes The actual license text is as follows: /*--------------------------------------------------------------------------------------- * C O P Y R I G H T *---------------------------------------------------------------------------------------- * Copyright (c) 2022 by Feaser www.feaser.com All rights reserved * *---------------------------------------------------------------------------------------- * L I C E N S E *---------------------------------------------------------------------------------------- * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */","title":"License"},{"location":"misra/","text":"MISRA compliance Static code analysis was performed to verify compliance with MISRA-C 2012. The following table lists the compliance exceptions: Directive Type Rationale 4.9 advisory Function-like macros can provide clarity and allow easy to understand compile time configurations. 11.5 advisory Conversions from pointer to void to pointer to other type. This is needed after allocating memory from the heap and then initializing a pointer to point to this allocated memory. Used for example when allocating memory to build a linked list.","title":"MISRA compliance"},{"location":"misra/#misra-compliance","text":"Static code analysis was performed to verify compliance with MISRA-C 2012. The following table lists the compliance exceptions: Directive Type Rationale 4.9 advisory Function-like macros can provide clarity and allow easy to understand compile time configurations. 11.5 advisory Conversions from pointer to void to pointer to other type. This is needed after allocating memory from the heap and then initializing a pointer to point to this allocated memory. Used for example when allocating memory to build a linked list.","title":"MISRA compliance"}]}